import argparse
from collections import deque
from functools import reduce


CCodeTpl = """
/**
 * This file is automatically generated by ./opcodes_builder.py
 * 
 * Any explicit changes to it will be lost at compilation.
 */

#ifndef OPCODE_H_GUARD
#define OPCODE_H_GUARD

#include <stdint.h>


typedef union value_u {{
    int64_t qw;
    double df;

    struct {{
        float fl;
        float fh;
    }};
    
    struct {{
        uint32_t dwl;
        uint32_t dwh;
    }};
    
    struct {{
        uint16_t wl;
        uint16_t wh;
    }};

    struct {{
        uint8_t bl;
        uint8_t bh;
    }};
}} value_t;


//typedef uint8_t opcode_t;
typedef enum opcode_e {{
    {opcodes}
}} __attribute__((__packed__)) opcode_t;

static_assert(sizeof(opcode_t) == 1);


typedef enum argType_e {{
    {argTypes}
}} __attribute__((__packed__)) argType_t;

static_assert(sizeof(argType_t) == 1);


typedef enum argLoc_e {{
    {argLocs}
}} __attribute__((__packed__)) argLoc_t;

static_assert(sizeof(argLoc_t) == 1);


{opnames}


static const uint64_t OPARG_BITMASK[256] {{
    {opargs}
}};


#endif // OPCODE_H_GUARD
""".lstrip()


# Opcode structure:
# [--------] ([----][--][--] arg)*
# ^~~ Opcode's numeric code
#            ^~~ Opcode arguments (fixed number for every instruction)
#             ^~~ Type (double float, float low, float high, double word low, double word high, etc...)
#                   ^~~ Location (immediate/stack/register)\
#                       ^~~ Register number, for "reg" type
#                            ^~~ The argument itself


verbosity = 0


def log(*args, level=1, **kwargs):
    if level <= verbosity:
        print("[DBG]", *args, **kwargs)


class AddressingMode(object):
    locs = {"stack": 0b00, "imm": 0b01, "reg": 0b10}
    types = {'df' : 0b0100, 
             'fl' : 0b0010, 
             'fh' : 0b0011, 
             'qw' : 0b1110, 
             'dwl': 0b1100, 
             'dwh': 0b1101,
             'wl' : 0b1010,
             'wh' : 0b1011, 
             'bl' : 0b1000, 
             'bh' : 0b1001}
    
    def __init__(self, type, loc):
        assert type in self.types
        assert loc in self.locs
        
        self.type = type
        self.loc = loc
    
    def encode(self):
        return self.types[self.type] << 4 | self.locs[self.loc] << 2


class OpcodeDefParser(object):
    def __init__(self, ifileName=None):
        self.buf = deque()
        self.opcodes = {}
        
        if ifileName is not None:
            self.read(ifileName)
    
    def read(self, ifileName):
        with open(ifileName, "r") as ifile:
            self.buf.extend(ifile.read().split('\n'))
    
    def write(self, ofileName):
        with open(ofileName, "w") as ofile:
            ofile.write(self.genCCode())
    
    def isEmpty(self):
        return len(self.buf) == 0
    
    def nextLine(self):
        assert not self.isEmpty()
        
        return self.buf.popleft()
    
    def parseAll(self):
        while not self.isEmpty():
            self.parseOpcodeDef()
    
    def parseOpcodeDef(self):
        line = self.nextLine().strip()
        
        if not line or line.startswith("#"):
            return
        
        log(line, flush=True)
        
        opnum, line = line.split(":", 1)
        
        try:
            opnum = int(opnum, 16)
        except ValueError:
            opnum = int(opnum, 10)
        
        assert opnum not in self.opcodes
        
        opname, arg = line.split("(", 1);
        opname = opname.strip()
        arg = arg.strip()
        
        assert arg.endswith(")")
        arg = arg[:-1]
        
        #args = args.split(';')  # For the future
        #assert len(args) == 1
        #for i in range(len(args)):
        #    args[i] = self.parseArg(args[i])
        
        self.opcodes[opnum] = (opname, self.parseArg(arg))
    
    def parseArg(self, arg):
        if arg.strip() == '':
            return []
        
        types, locs = arg.split(':')
        
        types = types.strip().split(',')
        locs = locs.strip().split(',')
        
        assert len(types) * len(locs) <= 4  # For simplicity, I guess
        
        argmodes = []
        
        for type in types:
            for loc in locs:
                argmodes.append(AddressingMode(type, loc))
        
        return argmodes
    
    def genCList(self, title, items, oneLine=False, compact=False, pad=True):
        assert not compact  # apparently, designated initializers don't work in c++ by the standard...
        
        assert isinstance(items, dict if compact else (list, tuple))
        
        data = []
        
        if compact:
            padding = max(max(map(lambda x: len(str(x)), items)), pad)
            
            for key, value in items.items():
                data.append("[{key}] = {value}".format(key=key.ljust(padding), value=value))
        else:
            for value in items:
                data.append("{value}".format(value=value))
        
        sep = ", " if oneLine else ",\n    "
        data = sep.join(data)
        
        return "{title} {{{initialPad}{data}{terminalPad}}};".format(title=title, initialPad=("\n    " if items and not oneLine else " " if items else ""), terminalPad=("\n" if items and not oneLine else " " if items else ""), data=data)
    
    def genCCode(self):
        #opnames = ',\n    '.join(("{name}".format(name=f'"{self.opcodes[ind][0]}"' if ind in self.opcodes else "NULL") for ind in range(256)))
        
        #opnames = self.genCList("static const char *OPNAMES[256] = ", dict([(f'0x{key:02x}', f'"{value[0]}"') for key, value in self.opcodes.items()]), compact=True)
        #opnames = self.genCList("static const char *OPNAMES[256] = ", dict([(f'OP_{value[0].upper()}', f'"{value[0]}"') for value in self.opcodes.values()]), compact=True)
        opnames = self.genCList("static const char *OPNAMES[256] = ", [(f'"{self.opcodes[ind][0]}"' if ind in self.opcodes else "NULL") for ind in range(256)], compact=False)
        
        #opargs = ',\n    '.join(["{{{}}}".format(
        #        ', '.join(["0b{argtype:08b}".format(argtype=self.opcodes[ind][1][typeind].encode()) if ind in self.opcodes else "" for typeind in range(len(self.opcodes[ind][1]))])
        #    ) for ind in range(256)])
        
        opargs = []
        
        for ind in range(256):
            if ind not in self.opcodes:
                opargs.append('0x{:016x}'.format(0))
                continue
            opargs.append('0x{:016x}'.format(reduce(lambda x, y: x | 1 << (y.encode() >> 2), self.opcodes[ind][1], 0)))
        
        opargs = ',\n    '.join(opargs)
        
        # TODO: Paddings
        
        padLength = max(map(lambda x: len(self.opcodes[x][0]), self.opcodes))
        #opcodes = '\n'.join(("const opcode_t OP_{name} = 0x{ind:02x};".format(name=self.opcodes[ind][0].upper(), ind=ind) for ind in self.opcodes))
        opcodes = ',\n    '.join(("OP_{name} = 0x{ind:02x}".format(name=self.opcodes[ind][0].upper().ljust(padLength), ind=ind) for ind in self.opcodes))
        
        argTypes = ',\n    '.join(["ARGTYPE_{name} = 0b{value:04b}".format(name=name.upper(), value=value) for name, value in AddressingMode.types.items()])
        
        argLocs = ',\n    '.join(["ARGLOC_{name} = 0b{value:02b}".format(name=name.upper(), value=value) for name, value in AddressingMode.locs.items()])
        
        return CCodeTpl.format(opnames=opnames, opargs=opargs, opcodes=opcodes, argTypes=argTypes, argLocs=argLocs);


if __name__ == "__main__":
    #parser = OpcodeDefParser()
    #print(parser.genCList("static const char *OPNAMES[256] = ", {"OP_PUSH": "\"push\"", "OP_POP": "\"pop\""}, compact=True))
    #exit()
    
    argParser = argparse.ArgumentParser()
    argParser.add_argument('-i', '--ifile', help='Input .def file name', default="opcodes.def")
    argParser.add_argument('-o', '--ofile', help='Output .h file name', default="opcodes.h")
    argParser.add_argument('-v', '--verbose', help='Increase verbosity', action='count', default=0)
    args = argParser.parse_args()
    
    verbosity = args.verbose
    
    parser = OpcodeDefParser(ifileName=args.ifile)
    
    parser.parseAll()
    
    parser.write(args.ofile)